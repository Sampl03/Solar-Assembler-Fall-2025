using Solar.Asm.Engine.Model.Code;
using Solar.Asm.Engine.Model.Exceptions;
using Solar.Asm.Engine.Model.Expressions;

namespace Solar.Asm.Engine.Model.IO
{
    /// <summary>
    /// Handles the translation and patching of assembly source and assembled code specific to an architecture
    /// </summary>
    public interface IAssemblyParser
    {
        public ArchitectureSpecs ArchSpecs { get; }

        /// <summary>
        /// Parse a source text string into a dialect-specific <see cref="Chunk"/>.<br/>
        /// It is the responsibility of the caller to parse expressions and provided them through the <paramref name="embeddedExpressions"/><br/>
        /// <br/>
        /// Expressions which have a <see cref="string"/> return type are to be embedded within the <paramref name="source"/> string passed to this method<br/>
        /// <br/>
        /// Embedded expressions of any other value are to be represented with the pattern <c>@$EXPR(n)$@</c>,
        /// where <c>n</c> is an index into <paramref name="embeddedExpressions"/>.<br/>
        /// Ownership of the expression entities is transfered to the generated <see cref="Chunk"/> as needed.
        /// </summary>
        /// <remarks>
        /// Should throw <see cref="UnrecognizedChunkException"/> if the parser does not recognize the chunk type<br/>
        /// Should throw <see cref="IncompatibleOperandException"/> if an operand expression is of the wrong type
        /// </remarks>
        /// <param name="context">The <see cref="Program"/> context to create a chunk within within</param>
        /// <param name="source">The source string to translate</param>
        /// <param name="embeddedExpressions">
        /// An array of <see cref="ExpressionBase"/> objects that the source string references
        /// </param>
        /// <returns>
        /// The new <see cref="Chunk"/> object to be inserted into the data model
        /// </returns>
        /// <exception cref="UnrecognizedChunkException"/>
        /// <exception cref="IncompatibleOperandException"/>
        public Chunk ParseChunk(Program context, string source, ExpressionBase[] embeddedExpressions);

        /// <summary>
        /// Returns a copy of the inputted byte stream with the patches applied.<br/>
        /// </summary>
        /// <br/>
        /// Behaviour is undefined if the <see cref="BinaryPatch"/> instances don't come from chunks
        /// generated by this <see cref="IAssemblyParser"/>
        /// <remarks>
        /// Should throw <see cref="UnrecognizedPatchException"/> if a <see cref="BinaryPatch"/> with an unrecognized patch ID is found
        /// </remarks>
        /// <param name="currentVirtualAddress">The virtual address of this data, used for PC-relative mathematics</param>
        /// <param name="data">The data to copy and patch</param>
        /// <param name="patches">The list of patches to apply</param>
        /// <exception cref="UnrecognizedPatchException"/>
        public byte[] PatchBytes(ulong currentVirtualAddress, byte[] data, BinaryPatch[] patches);
    }
}
